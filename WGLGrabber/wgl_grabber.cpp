// WGLGrabber.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

const char* generatedHdrName = "wgl_grabber_gen.h";
const char* generatedCppName = "wgl_grabber_gen.cpp";
const char* comment = "// This source code was automatically generated by WGLGrabber\r\n";

struct GLFunc
{
	GLFunc(){}
	GLFunc(const GLFunc& r) {
		*this = r;
	}
	const GLFunc& operator=(const GLFunc& r) {
		name = r.name;
		decl = r.decl;
		caster = r.caster;
		return *this;
	}
	std::string name;
	std::string decl;
	std::string caster;
};
std::vector<GLFunc> glFuncs;

void ParseHeader(std::string str, const char* regExp, const char* conventions)
{
	std::regex pattern(regExp);
	auto funcBegin = std::sregex_iterator(str.begin(), str.end(), pattern);
	auto End = std::sregex_iterator();
	int dist = std::distance(funcBegin, End);
	printf("%d functions found\n", dist);
	int i = 0;
	for (auto it = funcBegin; it != End; it++) {
		std::smatch m = *it;
		if (m.size() < 4) {
			continue;
		}
		GLFunc func;
		func.name = m[2].str();
		func.decl = m[1].str() + "(" + conventions + "*" + m[2].str() + ")" + m[3].str();
		func.caster = m[1].str() + "(" + conventions + "*)" + m[3].str();
		glFuncs.push_back(func);
		printf("\r%d/%d", ++i, dist);
	}
	printf("\n");
}

void CodeGen()
{
	std::string hdr, cpp;
	hdr = comment;
	hdr += "#include <windows.h>\r\n";
	hdr += "#include <gl/gl.h>\r\n";
//	hdr += "#include \"glheaders/glext.h\"\r\n";
	hdr += "#include \"glheaders/glcorearb.h\"\r\n";
	hdr += "#include \"glheaders/wglext.h\"\r\n";
	for (auto it : glFuncs) {
		hdr += std::string("extern ") + it.decl + ";\r\n";
	}
	hdr += "void WGLGrabberInit();\r\n";
	SaveFile(generatedHdrName, (uint8_t*)hdr.c_str(), hdr.size());

	cpp = comment;
	cpp += std::string("#include \"") + generatedHdrName + "\"\r\n";
	for (auto it : glFuncs) {
		cpp += it.decl + ";\r\n";
	}
	cpp += "void WGLGrabberInit()\r\n";
	cpp += "{\r\n";
	for (auto it : glFuncs) {
		cpp += std::string("\t") + it.name + " = (" + it.caster + ")wglGetProcAddress(\"" + it.name + "\");\r\n";
	}
	cpp += "}\r\n";
	SaveFile(generatedCppName, (uint8_t*)cpp.c_str(), cpp.size());
}

std::string LoadStr(const char* fileName)
{
	std::ifstream img(fileName);
	if (img.fail()) {
		printf("failed loading %s\n", fileName);
		return "";
	}
	printf("%s loaded\n", fileName);
	return std::string(std::istreambuf_iterator<char>(img), std::istreambuf_iterator<char>());
}

int _tmain(int argc, _TCHAR* argv[])
{
	GoMyDir();

	std::string core = LoadStr("glheaders/glcorearb.h");
	std::regex removeV10 = std::regex("#ifndef GL_VERSION_1_0[^]+#endif /\\* GL_VERSION_1_0 \\*/");
	std::regex removeV11 = std::regex("#ifndef GL_VERSION_1_1[^]+#endif /\\* GL_VERSION_1_1 \\*/");
	core = std::regex_replace(core, removeV10, "", std::regex_constants::match_default);
	core = std::regex_replace(core, removeV11, "", std::regex_constants::match_default);

//	ParseHeader(LoadStr("glheaders/glext.h"), "^GLAPI\\s+(\\w+)\\s+APIENTRY\\s+(gl\\w+)\\s*(\\(.*\\))", "APIENTRY");
	ParseHeader(core, "^GLAPI\\s+([\\w\\s\\*]+)APIENTRY\\s+(gl\\w+)\\s*(\\(.*\\))", "APIENTRY");
	ParseHeader(LoadStr("glheaders/wglext.h"), "^(\\w+(?:\\s+\\w+)*\\s+)WINAPI\\s+(wgl\\w+)\\s*(\\(.*\\))", "WINAPI");
	CodeGen();
	return 0;
}

